using Humanizer;
using NSwag;
using NSwag.CodeGeneration.TypeScript;

namespace SwaggerToFetchGenerator;

public static class ResultGenerator
{
    public static void GetResult(GeneratorOption option)
    {
        OpenApiDocument document = null;
        if (!string.IsNullOrWhiteSpace(option.SwaggerFile))
        {
            if (string.IsNullOrWhiteSpace(option.SwaggerFile) || !IsValidPath(option.SwaggerFile))
            {
                Console.WriteLine("'file' is not valid.");
                return;
            }
            document = OpenApiDocument.FromFileAsync(option.SwaggerFile).GetAwaiter().GetResult();

        }
        if (!string.IsNullOrWhiteSpace(option.SwaggerUrl) && document == null)
        {
            if (!IsValidUri(option.SwaggerUrl))
            {
                Console.WriteLine("'url' is not valid.");
                return;
            }
            document = OpenApiDocument.FromUrlAsync(option.SwaggerUrl).GetAwaiter().GetResult();
        }
        else
        {
            Console.WriteLine("'url' is not valid.");
            return;
        }
        var settings = new TypeScriptClientGeneratorSettings
        {
            ClassName = option.Name,
            GenerateDtoTypes = true,
            GenerateClientInterfaces = true,
            GenerateClientClasses = true,
            GenerateResponseClasses = true,
            TypeScriptGeneratorSettings =
            {
                ExportTypes = true,
            }
        };
        var generator = new TypeScriptClientGenerator(document, settings);
        var source = generator.GenerateFile();
        var configSource = string.Empty;
        if (option.HasConfig)
        {
            var configName = option.Name + "Config";
            configSource = $$"""
                             // <auto-generated>
                             
                             /* tslint:disable */
                             /* eslint-disable */
                             // ReSharper disable InconsistentNaming

                             /*
                             const {{configName.Camelize()}} = {{configName}}({
                                 bearerToken: 'ABCabc123...'
                             });
                             const {{option.Name.Camelize()}} = new {{option.Name}}('https://...', {{configName.Camelize()}})
                             */
                             
                             export interface {{configName}} {
                                 bearerToken: string
                             }

                             export const {{configName}} = (options: {{configName}}) => {
                                 return {
                                     fetch: (url: RequestInfo, init: RequestInit) => {
                                         init.headers = {
                                             ...init.headers,
                                             ...{
                                                 Authorization: `Bearer ${options.bearerToken}`,
                                             },
                                         };
                                         return fetch(url, init);
                                     },
                                 };
                             };
                             """.Trim();

        }
        var fileName = option.Name.Kebaberize();
        if (string.IsNullOrWhiteSpace(option.SaveTo))
        {
            Console.WriteLine("'save' is not valid.");
            return;
        }
        if (!Directory.Exists(option.SaveTo))
        {
            try
            {
                Directory.CreateDirectory(option.SaveTo);
            }
            catch
            {
                Console.WriteLine("'save' is not valid.");
                return;
            }
        }
        File.WriteAllText( Path.Combine(option.SaveTo,$"{fileName}.ts"), source);
        if (!string.IsNullOrWhiteSpace(configSource))
        {
            File.WriteAllText(Path.Combine(option.SaveTo, $"{fileName}-config.ts"), configSource);
        }
    }
    private static bool IsValidPath(this string path, bool allowRelativePaths = false)
    {
        bool isValid;
        try
        {
            var _ = Path.GetFullPath(path);
            if (allowRelativePaths)
            {
                isValid = Path.IsPathRooted(path);
            }
            else
            {
                var root = Path.GetPathRoot(path);
                isValid = string.IsNullOrEmpty(root?.Trim('\\', '/'));
            }
        }
        catch
        {
            isValid = false;
        }
        return isValid;
    }
    private static bool IsValidUri(this string uri)
    {
        return Uri.TryCreate(uri, UriKind.Absolute, out var result) && (result.Scheme == Uri.UriSchemeHttp || result.Scheme == Uri.UriSchemeHttps);
    }
}